/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/asset-upload': {
    /**
     * Upload creative assets
     * @description Upload creative assets (images, videos, audio) to Google Cloud Storage.
     *
     * **REQUIRED FIELDS:**
     * - `brandAgentId`: Brand agent ID for file organization
     * - `assets`: Array of assets (each with name, contentType, data, assetType)
     *
     * Returns signed URLs valid for 1 hour.
     */
    post: operations['asset_upload'];
  };
  '/asset-list': {
    /**
     * List creative assets
     * @description List creative assets stored in Google Cloud Storage. Filter by customer and/or brand agent.
     */
    post: operations['asset_list'];
  };
  '/brand-agent-list': {
    /**
     * List brand agents
     * @description List all brand agents (advertiser accounts) for the authenticated customer. Authentication is automatic - no parameters required.
     */
    post: operations['brand_agent_list'];
  };
  '/brand-agent-create': {
    /**
     * Create brand agent
     * @description Create a new brand agent (advertiser account). This creates the top-level container that will own campaigns, creatives, audiences, standards, and measurement sources.
     */
    post: operations['brand_agent_create'];
  };
  '/brand-agent-get': {
    /**
     * Get brand agent
     * @description Get detailed information about a specific brand agent (advertiser account) by ID.
     */
    post: operations['brand_agent_get'];
  };
  '/brand-agent-update': {
    /**
     * Update brand agent
     * @description Update the name or description of an existing brand agent (advertiser account). This only updates metadata - campaigns, creatives, and other resources remain unchanged.
     */
    post: operations['brand_agent_update'];
  };
  '/brand-agent-delete': {
    /**
     * Delete brand agent
     * @description ⚠️ DANGER - Permanently delete a brand agent (advertiser account) and ALL associated data including campaigns, creatives, audiences, standards, and measurement sources. This action cannot be undone.
     */
    post: operations['brand_agent_delete'];
  };
  '/brand-standards-list': {
    /**
     * List brand standards
     * @description List all brand safety standards. Brand standards define safety rules and filtering criteria using AI-powered prompts.
     */
    post: operations['brand_standards_list'];
  };
  '/brand-standards-create': {
    /**
     * Create brand standard
     * @description Create a new brand safety standard for a brand. The standard uses AI to classify content and enforce brand safety rules based on a natural language prompt.
     */
    post: operations['brand_standards_create'];
  };
  '/brand-standards-delete': {
    /**
     * Delete brand standard
     * @description ⚠️ DANGER - Permanently delete a brand standard. This will remove all safety rules and models associated with this standard.
     */
    post: operations['brand_standards_delete'];
  };
  '/brand-story-list': {
    /**
     * List brand stories
     * @description List all brand stories for a brand. Brand stories are AI-powered target audience definitions using natural language prompts.
     */
    post: operations['brand_story_list'];
  };
  '/brand-story-create': {
    /**
     * Create brand story
     * @description Create a new brand story for a brand. Brand stories are AI-powered target audience definitions that use natural language prompts to define audience profiles, demographics, and behavioral characteristics.
     */
    post: operations['brand_story_create'];
  };
  '/brand-story-update': {
    /**
     * Update brand story
     * @description Update the audience definition prompt of an existing brand story. This creates a new model version with the updated definition.
     */
    post: operations['brand_story_update'];
  };
  '/brand-story-delete': {
    /**
     * Delete brand story
     * @description ⚠️ DANGER - Permanently delete a brand story. This will remove all audience definitions and models associated with this story.
     */
    post: operations['brand_story_delete'];
  };
  '/campaign-list': {
    /**
     * List campaigns
     * @description List campaigns for the authenticated customer, with optional filtering.
     */
    post: operations['campaign_list'];
  };
  '/campaign-create': {
    /**
     * Create campaign
     * @description Create a new campaign with natural language prompt. The backend will parse the prompt to extract targeting, budget, and creative requirements.
     */
    post: operations['campaign_create'];
  };
  '/campaign-update': {
    /**
     * Update campaign
     * @description Update an existing campaign's settings.
     */
    post: operations['campaign_update'];
  };
  '/campaign-delete': {
    /**
     * Delete campaign
     * @description ⚠️ DANGER - Permanently delete a campaign and all associated data.
     */
    post: operations['campaign_delete'];
  };
  '/campaign-get-summary': {
    /**
     * Get campaign summary
     * @description Get detailed summary information about a specific campaign.
     */
    post: operations['campaign_get_summary'];
  };
  '/campaign-list-tactics': {
    /**
     * List campaign tactics
     * @description List all tactics associated with a specific campaign.
     */
    post: operations['campaign_list_strategies'];
  };
  '/campaign-validate-brief': {
    /**
     * Validate campaign brief
     * @description Validate a campaign brief to ensure it contains all necessary information.
     */
    post: operations['campaign_validate_brief'];
  };
  '/channel-list': {
    /**
     * List channels
     * @description List all available advertising channels.
     */
    post: operations['channel_list'];
  };
  '/creative-list': {
    /**
     * List creatives
     * @description List creatives for the authenticated customer, with optional filtering.
     */
    post: operations['creative_list'];
  };
  '/creative-create': {
    /**
     * Create creative
     * @description Create a new creative with specified details. Supports various format sources (ADCP, CREATIVE_AGENT, PUBLISHER) and assembly methods.
     *
     * **Two workflows supported:**
     * 1. **Separate upload**: Use asset_upload first, then reference asset IDs in content.assetIds
     * 2. **Inline upload**: Upload assets directly in the `assets` array (automatically uploaded and linked)
     */
    post: operations['creative_create'];
  };
  '/creative-get': {
    /**
     * Get creative
     * @description Get detailed information about a specific creative.
     */
    post: operations['creative_get'];
  };
  '/creative-update': {
    /**
     * Update creative
     * @description Update an existing creative's settings.
     */
    post: operations['creative_update'];
  };
  '/creative-delete': {
    /**
     * Delete creative
     * @description ⚠️ DANGER - Permanently delete a creative.
     */
    post: operations['creative_delete'];
  };
  '/creative-assign': {
    /**
     * Assign creative to campaign
     * @description Assign a creative to a campaign. Automatically discovers and syncs the creative to all sales agents
     * associated with the campaign via active media buys. Returns auto-sync results including which agents
     * received the creative and their approval status.
     */
    post: operations['creative_assign'];
  };
  '/creative-sync-sales-agents': {
    /**
     * Sync creative with sales agents
     * @description Sync a creative to sales agents using smart auto-detection or manual specification.
     * Features intelligent format matching and recent activity analysis (30-60 day lookback).
     * Provides detailed sync status and actionable next steps.
     */
    post: operations['creative_sync_sales_agents'];
  };
  '/sales-agent-list': {
    /**
     * List sales agents
     * @description List all registered sales agents (publishers) for the authenticated customer.
     */
    post: operations['sales_agent_list'];
  };
  '/sales-agent-get': {
    /**
     * Get sales agent
     * @description Get detailed information about a specific sales agent.
     */
    post: operations['sales_agent_get'];
  };
  '/sales-agent-register': {
    /**
     * Register sales agent
     * @description Register a new sales agent. Creates a row in the adcp_agent table. Organization ID is auto-detected from customer if not provided.
     */
    post: operations['sales_agent_register'];
  };
  '/sales-agent-account-list': {
    /**
     * List accounts for a sales agent
     * @description List all accounts registered by your organization for a specific sales agent.
     */
    post: operations['sales_agent_account_list'];
  };
  '/sales-agent-account-register': {
    /**
     * Register account for sales agent
     * @description Register your organization's account to an existing sales agent. This allows you to access the sales agent's inventory and services.
     */
    post: operations['sales_agent_account_register'];
  };
  '/sales-agent-unregister': {
    /**
     * Unregister sales agent completely
     * @description Completely unregister a sales agent - deactivates ALL customer accounts and disables the agent itself. Only the owner can perform this action.
     */
    post: operations['sales_agent_unregister'];
  };
  '/sales-agent-account-unregister': {
    /**
     * Unregister your account with a sales agent
     * @description Unregister (deactivate) your organization's account with a sales agent. This only deactivates your account but doesn't affect the sales agent or other customers' accounts.
     */
    post: operations['sales_agent_account_unregister'];
  };
  '/sales-agent-update': {
    /**
     * Update sales agent
     * @description Update a sales agent's core settings like name, description, or endpoint URL. Only the owner can perform this action.
     */
    post: operations['sales_agent_update'];
  };
  '/sales-agent-account-update': {
    /**
     * Update sales agent account authentication
     * @description Update your organization's account authentication configuration for a sales agent. This endpoint only handles authentication updates.
     */
    post: operations['sales_agent_account_update'];
  };
  '/tactic-list': {
    /**
     * List tactics
     * @description List all media buying tactics for the authenticated customer.
     */
    post: operations['strategy_list'];
  };
  '/tactic-create': {
    /**
     * Create tactic
     * @description Create a new AMP media buy tactic for executing media buys with publishers. Tactics are automatically configured as activityType=AMP and tacticType=INTELLIGENT_CAMPAIGNS. Use channel_list to see valid channel codes.
     */
    post: operations['strategy_create'];
  };
  '/tactic-get': {
    /**
     * Get tactic
     * @description Get detailed information about a specific tactic.
     */
    post: operations['strategy_get'];
  };
  '/tactic-update': {
    /**
     * Update tactic
     * @description Update an existing tactic's configuration.
     */
    post: operations['strategy_update'];
  };
  '/tactic-delete': {
    /**
     * Delete tactic
     * @description ⚠️ DANGER - Permanently delete a tactic.
     */
    post: operations['strategy_delete'];
  };
  '/tactic-link-campaign': {
    /**
     * Link campaign to tactic
     * @description Link a campaign to a tactic for budget and execution management.
     */
    post: operations['strategy_link_campaign'];
  };
  '/tactic-unlink-campaign': {
    /**
     * Unlink campaign from tactic
     * @description Unlink a campaign from a tactic.
     */
    post: operations['strategy_unlink_campaign'];
  };
  '/media-buy-list': {
    /**
     * List media buys
     * @description List all media buys for the authenticated customer.
     */
    post: operations['media_buy_list'];
  };
  '/media-buy-create': {
    /**
     * Create media buy
     * @description Create a new media buy to execute a tactic with one or more publisher products. A media buy represents the actual execution of a tactic with budget allocation and pricing.
     *
     * **Multi-Product Support**: Media buys now support multiple products from different sales agents in a single buy. Each product can have its own budget allocation and pricing. During execution, each unique sales agent will receive a separate ADCP submission.
     *
     * **Budget Validation**: The sum of product budget allocations must not exceed the total media buy budget. The system will validate this at creation time and show warnings if budget is under-allocated.
     */
    post: operations['media_buy_create'];
  };
  '/media-buy-get': {
    /**
     * Get media buy
     * @description Get detailed information about a specific media buy.
     */
    post: operations['media_buy_get'];
  };
  '/media-buy-update': {
    /**
     * Update media buy
     * @description Update an existing media buy's configuration.
     */
    post: operations['media_buy_update'];
  };
  '/media-buy-delete': {
    /**
     * Delete media buy
     * @description ⚠️ DANGER - Permanently delete a media buy.
     */
    post: operations['media_buy_delete'];
  };
  '/media-buy-execute': {
    /**
     * Execute media buy
     * @description Execute a media buy by deploying it to the publisher platform.
     */
    post: operations['media_buy_execute'];
  };
  '/notifications-list': {
    /**
     * List notifications
     * @description List notifications for the authenticated user.
     */
    post: operations['notifications_list'];
  };
  '/notifications-mark-read': {
    /**
     * Mark notification as read
     * @description Mark a specific notification as read.
     */
    post: operations['notifications_mark_read'];
  };
  '/notifications-mark-acknowledged': {
    /**
     * Mark notification as acknowledged
     * @description Mark a specific notification as acknowledged.
     */
    post: operations['notifications_mark_acknowledged'];
  };
  '/notifications-mark-all-read': {
    /**
     * Mark all notifications as read
     * @description Mark all notifications as read for the authenticated user.
     */
    post: operations['notifications_mark_all_read'];
  };
  '/media-product-list': {
    /**
     * List media products
     * @description List available media products from publishers.
     */
    post: operations['media_product_list'];
  };
  '/media-product-discover': {
    /**
     * Discover media products
     * @description Discover new media products from connected publishers.
     */
    post: operations['media_product_discover'];
  };
  '/media-product-sync': {
    /**
     * Sync media products
     * @description Synchronize media product inventory with publisher systems.
     */
    post: operations['media_product_sync'];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    AssetUpload: {
      /**
       * @description **REQUIRED**: Original filename
       * @example logo.png
       */
      name: string;
      /**
       * @description **REQUIRED**: MIME type
       * @example image/png
       * @enum {string}
       */
      contentType:
        | 'image/png'
        | 'image/jpeg'
        | 'image/jpg'
        | 'image/gif'
        | 'image/webp'
        | 'video/mp4'
        | 'video/webm'
        | 'audio/mp3'
        | 'audio/wav'
        | 'font/woff'
        | 'font/woff2';
      /**
       * Format: byte
       * @description **REQUIRED**: Base64-encoded file data (without data:image/png;base64, prefix)
       * @example iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==
       */
      data: string;
      /**
       * @description **REQUIRED**: Type of asset. Must be one of: image, video, audio, logo, font
       * @example image
       * @enum {string}
       */
      assetType: 'image' | 'video' | 'audio' | 'logo' | 'font';
      /**
       * @description Optional tags for organization
       * @example [
       *   "brand",
       *   "header",
       *   2024
       * ]
       */
      tags?: string[];
    };
    Budget: {
      /** @description Total budget amount in cents (e.g., 5000000 = $50,000) */
      total: number;
      /**
       * @description Budget currency
       * @enum {string}
       */
      currency: 'USD' | 'EUR' | 'GBP' | 'CAD' | 'AUD';
      /** @description Daily spending limit in cents */
      dailyCap?: number;
      /**
       * @description Budget pacing tactic
       * @enum {string}
       */
      pacing?: 'even' | 'accelerated' | 'front_loaded';
    };
    ScoringWeights: {
      /** @description Weight for affinity scoring (0-1) */
      affinity?: number;
      /** @description Weight for outcome scoring (0-1) */
      outcome?: number;
      /** @description Weight for quality scoring (0-1) */
      quality?: number;
    };
    BrandAgent: {
      /** @description Unique brand agent identifier */
      id: string;
      /** @description Brand agent name */
      name: string;
      /** @description Brand agent description */
      description?: string;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
    };
    Campaign: {
      /** @description Unique campaign identifier */
      id: string;
      /** @description Campaign name */
      name: string;
      /** @description Natural language campaign description */
      prompt: string;
      /** @description Parent brand agent ID */
      brandAgentId: string;
      /**
       * @description Campaign status
       * @enum {string}
       */
      status: 'active' | 'paused' | 'completed' | 'draft';
      budget?: components['schemas']['Budget'];
      /** @description Associated synthetic audience IDs */
      audienceIds?: string[];
      /** @description Associated creative asset IDs */
      creativeIds?: string[];
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
    };
    Creative: {
      /** @description Unique creative identifier */
      id: string;
      /** @description Creative name */
      name: string;
      /**
       * @description Creative asset type
       * @enum {string}
       */
      type: 'video' | 'image' | 'native' | 'html5';
      /**
       * Format: uri
       * @description Creative asset URL
       */
      url: string;
      /** @description Parent brand agent ID */
      brandAgentId: string;
      /** @description Creative headline text */
      headline?: string;
      /** @description Creative body text */
      body?: string;
      /** @description Call-to-action text */
      cta?: string;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
    };
    Tactic: {
      /** @description Unique tactic identifier */
      id: string;
      /** @description Tactic name */
      name: string;
      /** @description Associated campaign ID */
      campaignId: string;
      /** @description Tactical brief or prompt */
      prompt?: string;
      /**
       * @description Activity type (always AMP)
       * @enum {string}
       */
      activityType: 'AMP';
      /**
       * @description Tactic type
       * @enum {string}
       */
      tacticType: 'INTELLIGENT_CAMPAIGNS';
      /** @description Target channels (official codes) */
      channelCodes?: (
        | 'DIGITAL-AUDIO'
        | 'DISPLAY-WEB'
        | 'DISPLAY-APP'
        | 'CTV-BVOD'
        | 'OLV'
        | 'DOOH'
        | 'SOCIAL'
      )[];
      /** @description Target countries */
      countryCodes?: string[];
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
    };
    MediaBuy: {
      /** @description Unique media buy identifier */
      id: string;
      /** @description Media buy name */
      name: string;
      /** @description Media buy description */
      description?: string;
      /** @description Associated tactic ID */
      tacticId: string;
      /** @description Publisher/sales agent ID */
      salesAgentId: string;
      /** @description Media product ID */
      mediaProductId: string;
      budget: {
        amount?: number;
        currency?: string;
        dailyCap?: number;
        pacing?: string;
      };
      /** @description CPM pricing */
      cpm: number;
      /** @description Additional signal cost */
      signalCost?: number;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
    };
  };
  responses: {
    /** @description Successful tool execution */
    ToolResponse: {
      content: {
        'application/json': {
          /** @description Whether the operation succeeded */
          success?: boolean;
          /** @description Human-readable response message */
          message?: string;
          /** @description Response data (varies by tool) */
          data?: Record<string, never>;
        };
      };
    };
    /** @description Bad request - invalid parameters */
    BadRequest: {
      content: {
        'application/json': {
          /** @description Error message */
          error?: string;
          /** @description Additional error details */
          details?: Record<string, never>;
        };
      };
    };
    /** @description Unauthorized - invalid or missing authentication */
    Unauthorized: {
      content: {
        'application/json': {
          /** @description Error message */
          error?: string;
        };
      };
    };
    /** @description Resource not found */
    NotFound: {
      content: {
        'application/json': {
          /** @description Error message */
          error?: string;
        };
      };
    };
    /** @description Internal server error */
    InternalError: {
      content: {
        'application/json': {
          /** @description Error message */
          error?: string;
        };
      };
    };
  };
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {
  /**
   * Upload creative assets
   * @description Upload creative assets (images, videos, audio) to Google Cloud Storage.
   *
   * **REQUIRED FIELDS:**
   * - `brandAgentId`: Brand agent ID for file organization
   * - `assets`: Array of assets (each with name, contentType, data, assetType)
   *
   * Returns signed URLs valid for 1 hour.
   */
  asset_upload: {
    requestBody: {
      content: {
        'application/json': {
          /**
           * @description **REQUIRED**: Brand agent ID for file organization (e.g., brand_agent_123)
           * @example brand_agent_abc123
           */
          brandAgentId: string;
          /** @description **REQUIRED**: Array of assets to upload. Each asset must have all required fields. */
          assets: components['schemas']['AssetUpload'][];
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * List creative assets
   * @description List creative assets stored in Google Cloud Storage. Filter by customer and/or brand agent.
   */
  asset_list: {
    requestBody: {
      content: {
        'application/json': {
          /** @description Optional brand agent ID to filter assets */
          brandAgentId?: string;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * List brand agents
   * @description List all brand agents (advertiser accounts) for the authenticated customer. Authentication is automatic - no parameters required.
   */
  brand_agent_list: {
    requestBody: {
      content: {
        'application/json': Record<string, never>;
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Create brand agent
   * @description Create a new brand agent (advertiser account). This creates the top-level container that will own campaigns, creatives, audiences, standards, and measurement sources.
   */
  brand_agent_create: {
    requestBody: {
      content: {
        'application/json': {
          /** @description Name of the brand agent (advertiser account) */
          name: string;
          /** @description Optional description of the brand agent */
          description?: string;
          /** @description Friendly name for easy identification (e.g., 'Nike' for 'Nike c/o Kinesso') */
          nickname?: string;
          /** @description Your internal ID for this brand agent (e.g., client code or account ID) */
          externalId?: string;
          /** @description Domains where users will be sent from all campaigns/creatives */
          advertiserDomains?: string[];
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Get brand agent
   * @description Get detailed information about a specific brand agent (advertiser account) by ID.
   */
  brand_agent_get: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the brand agent to retrieve */
          brandAgentId: string;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Update brand agent
   * @description Update the name or description of an existing brand agent (advertiser account). This only updates metadata - campaigns, creatives, and other resources remain unchanged.
   */
  brand_agent_update: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the brand agent to update */
          brandAgentId: string;
          /** @description New name for the brand agent */
          name?: string;
          /** @description New description for the brand agent */
          description?: string;
          /** @description Enable/disable tactic seed data cooperative participation */
          tacticSeedDataCoop?: boolean;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Delete brand agent
   * @description ⚠️ DANGER - Permanently delete a brand agent (advertiser account) and ALL associated data including campaigns, creatives, audiences, standards, and measurement sources. This action cannot be undone.
   */
  brand_agent_delete: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the brand agent to delete permanently */
          brandAgentId: string;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * List brand standards
   * @description List all brand safety standards. Brand standards define safety rules and filtering criteria using AI-powered prompts.
   */
  brand_standards_list: {
    requestBody: {
      content: {
        'application/json': {
          /** @description Optional filtering criteria */
          where?: {
            /** @description Filter by name */
            name?: string;
          };
          /** @description Optional ordering for results */
          orderBy?: {
            /** @enum {string} */
            id?: 'asc' | 'desc';
            /** @enum {string} */
            name?: 'asc' | 'desc';
          };
          /** @description Number of records to return (pagination) */
          take?: number;
          /** @description Number of records to skip (pagination) */
          skip?: number;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Create brand standard
   * @description Create a new brand safety standard for a brand. The standard uses AI to classify content and enforce brand safety rules based on a natural language prompt.
   */
  brand_standards_create: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the brand to create standards for */
          brandAgentId: string;
          /** @description Name for the brand standard (optional - defaults to "{Brand Name} Standards") */
          name?: string;
          /** @description Natural language prompt defining the brand safety standards, content restrictions, and enforcement rules */
          prompt: string;
          /** @description Description for the brand standard */
          description?: string;
          /** @description Whether to create the standard as archived */
          isArchived?: boolean;
          /** @description List of country codes to target (e.g., ['US', 'CA']) */
          countries?: string[];
          /** @description List of channels to target (e.g., ['web', 'social']) */
          channels?: string[];
          /** @description List of specific brands this applies to */
          brands?: string[];
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Delete brand standard
   * @description ⚠️ DANGER - Permanently delete a brand standard. This will remove all safety rules and models associated with this standard.
   */
  brand_standards_delete: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the brand standard to delete */
          brandStandardId: string;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * List brand stories
   * @description List all brand stories for a brand. Brand stories are AI-powered target audience definitions using natural language prompts.
   */
  brand_story_list: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the brand to list brand stories for */
          brandAgentId: string;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Create brand story
   * @description Create a new brand story for a brand. Brand stories are AI-powered target audience definitions that use natural language prompts to define audience profiles, demographics, and behavioral characteristics.
   */
  brand_story_create: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the brand to create a brand story for */
          brandAgentId: string;
          /** @description Name for the brand story (e.g., 'Tech Enthusiasts', 'Luxury Shoppers') */
          name: string;
          /** @description Natural language prompt defining the target audience profile, demographics, and behavioral characteristics */
          prompt: string;
          /** @description List of country codes to target (e.g., ['US', 'CA']) */
          countries?: string[];
          /** @description List of channels to target (e.g., ['web', 'social']) */
          channels?: string[];
          /** @description List of language codes to target (e.g., ['en', 'es']) */
          languages?: string[];
          /** @description List of specific brands this applies to */
          brands?: string[];
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Update brand story
   * @description Update the audience definition prompt of an existing brand story. This creates a new model version with the updated definition.
   */
  brand_story_update: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the brand story to update */
          brandStoryId: string;
          /** @description New audience definition prompt */
          prompt: string;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Delete brand story
   * @description ⚠️ DANGER - Permanently delete a brand story. This will remove all audience definitions and models associated with this story.
   */
  brand_story_delete: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the brand story to delete */
          brandStoryId: string;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * List campaigns
   * @description List campaigns for the authenticated customer, with optional filtering.
   */
  campaign_list: {
    requestBody: {
      content: {
        'application/json': {
          /** @description Optional brand agent ID to filter campaigns */
          brandAgentId?: string;
          /**
           * @description Optional status filter
           * @enum {string}
           */
          status?: 'ACTIVE' | 'PAUSED' | 'ARCHIVED';
          /** @description Maximum number of campaigns to return (default 100) */
          limit?: number;
          /** @description Number of campaigns to skip for pagination */
          offset?: number;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Create campaign
   * @description Create a new campaign with natural language prompt. The backend will parse the prompt to extract targeting, budget, and creative requirements.
   */
  campaign_create: {
    requestBody: {
      content: {
        'application/json': {
          /** @description Optional brand agent ID that will own this campaign */
          brandAgentId?: string;
          /** @description Optional name for the campaign (auto-generated if not provided) */
          name?: string;
          /** @description Natural language description of campaign requirements (e.g., 'Create a video campaign targeting tech enthusiasts with $50k budget') */
          prompt: string;
          budget?: components['schemas']['Budget'];
          /**
           * Format: date-time
           * @description Campaign start date (ISO 8601 format)
           */
          startDate?: string;
          /**
           * Format: date-time
           * @description Campaign end date (ISO 8601 format)
           */
          endDate?: string;
          scoringWeights?: components['schemas']['ScoringWeights'];
          /** @description Days for outcome measurement window */
          outcomeScoreWindowDays?: number;
          /** @description Array of segment IDs to associate with campaign */
          segmentIds?: string[];
          /** @description Array of deal IDs to associate with campaign */
          dealIds?: string[];
          /**
           * @description Campaign visibility setting
           * @enum {string}
           */
          visibility?: 'PUBLIC' | 'PRIVATE';
          /**
           * @description How the campaign was created
           * @enum {string}
           */
          creationType?: 'MANUAL' | 'AUTO_SYNC';
          /**
           * @description Initial campaign status
           * @enum {string}
           */
          status?: 'ACTIVE' | 'PAUSED' | 'ARCHIVED';
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Update campaign
   * @description Update an existing campaign's settings.
   */
  campaign_update: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the campaign to update */
          campaignId: string;
          /** @description New name for the campaign */
          name?: string;
          /** @description Updated natural language campaign requirements */
          prompt?: string;
          /**
           * @description New status for the campaign
           * @enum {string}
           */
          status?: 'ACTIVE' | 'PAUSED' | 'ARCHIVED';
          budget?: components['schemas']['Budget'];
          /**
           * Format: date-time
           * @description Campaign start date (ISO 8601 format)
           */
          startDate?: string;
          /**
           * Format: date-time
           * @description Campaign end date (ISO 8601 format)
           */
          endDate?: string;
          /** @description Scoring weights configuration */
          scoringWeights?: {
            /** @description Weight for affinity scoring (0-1) */
            affinity?: number;
            /** @description Weight for outcome scoring (0-1) */
            outcome?: number;
            /** @description Weight for quality scoring (0-1) */
            quality?: number;
          };
          /** @description Days for outcome measurement window */
          outcomeScoreWindowDays?: number;
          /** @description Array of segment IDs to associate with campaign */
          segmentIds?: string[];
          /** @description Array of deal IDs to associate with campaign */
          dealIds?: string[];
          /**
           * @description Campaign visibility setting
           * @enum {string}
           */
          visibility?: 'PUBLIC' | 'PRIVATE';
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Delete campaign
   * @description ⚠️ DANGER - Permanently delete a campaign and all associated data.
   */
  campaign_delete: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the campaign to delete */
          campaignId: string;
          /** @description If true, permanently delete the campaign. Default false (soft delete/archive) */
          hardDelete?: boolean;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Get campaign summary
   * @description Get detailed summary information about a specific campaign.
   */
  campaign_get_summary: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the campaign to retrieve */
          campaignId: string;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * List campaign tactics
   * @description List all tactics associated with a specific campaign.
   */
  campaign_list_strategies: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the campaign to list tactics for */
          campaignId: string;
          /** @description Include archived tactics (defaults to false) */
          includeArchived?: boolean;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Validate campaign brief
   * @description Validate a campaign brief to ensure it contains all necessary information.
   */
  campaign_validate_brief: {
    requestBody: {
      content: {
        'application/json': {
          /** @description Campaign brief to validate */
          brief: string;
          /** @description Optional brand agent ID for context-aware validation */
          brandAgentId?: string;
          /**
           * @description Minimum quality score required to pass validation
           * @default 70
           */
          threshold?: number;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * List channels
   * @description List all available advertising channels.
   */
  channel_list: {
    requestBody: {
      content: {
        'application/json': Record<string, never>;
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * List creatives
   * @description List creatives for the authenticated customer, with optional filtering.
   */
  creative_list: {
    requestBody: {
      content: {
        'application/json': {
          /** @description Optional internal brand agent ID to filter creatives */
          brandAgentId?: number;
          /** @description Optional internal campaign ID to filter creatives */
          campaignId?: number;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Create creative
   * @description Create a new creative with specified details. Supports various format sources (ADCP, CREATIVE_AGENT, PUBLISHER) and assembly methods.
   *
   * **Two workflows supported:**
   * 1. **Separate upload**: Use asset_upload first, then reference asset IDs in content.assetIds
   * 2. **Inline upload**: Upload assets directly in the `assets` array (automatically uploaded and linked)
   */
  creative_create: {
    requestBody: {
      content: {
        'application/json': {
          /**
           * @description **REQUIRED**: Internal database ID of the brand agent that will own this creative
           * @example 1
           */
          brandAgentId: number;
          /** @description Optional internal database ID of the organization */
          organizationId?: number;
          /**
           * @description **REQUIRED**: Name for the creative
           * @example Banner Ad 970x250
           */
          name: string;
          /**
           * @description Optional description of the creative
           * @example Display banner for homepage
           */
          description?: string;
          /**
           * @description Format source type
           * @example ADCP
           * @enum {string}
           */
          formatSource?: 'ADCP' | 'CREATIVE_AGENT' | 'PUBLISHER';
          /**
           * @description Format identifier (e.g., "display_970x250", "video/mp4")
           * @example display_970x250
           */
          formatId?: string;
          /**
           * @description URL to the creative media file (video, image, etc.)
           * @example https://example.com/banner.png
           */
          mediaUrl?: string;
          /** @description Optional: Upload assets inline with the creative. Automatically uploaded to GCS and linked. */
          assets?: components['schemas']['AssetUpload'][];
          /** @description Creative content as JSON. Can include assetIds (existing or from inline upload), htmlSnippet, vastTag, etc. */
          content?: {
            /**
             * @description Array of existing asset IDs (from previous asset_upload). Inline uploaded assets are automatically added to this.
             * @example [
             *   "asset_abc123",
             *   "asset_def456"
             * ]
             */
            assetIds?: string[];
            /**
             * @description HTML5 creative snippet
             * @example <div>Ad content</div>
             */
            htmlSnippet?: string;
            /** @description VAST XML tag for video ads */
            vastTag?: string;
          };
          /**
           * @description Assembly method
           * @example ACTIVATION
           * @enum {string}
           */
          assemblyMethod?: 'CREATIVE_AGENT' | 'ACTIVATION' | 'PUBLISHER';
          /**
           * @description Optional internal database ID of campaign to assign creative to
           * @example 1
           */
          campaignId?: number;
        };
      };
    };
    responses: {
      /** @description Creative created successfully */
      200: {
        content: {
          'application/json': {
            /** @example true */
            success?: boolean;
            /**
             * @description Success message with creative details including creativeId (external string ID for use in media_buy_create/update), internal ID, and uploaded assets (if any)
             * @example ✅ **Creative Created Successfully!**
             *
             * **Creative ID:** newcreativevideo_xntthe4w (use this for media_buy_create/update)
             * **Internal ID:** 16
             * **Name:** My Creative
             * **Status:** PENDING
             * **Assets Uploaded:** 2
             * **Asset IDs:** asset_abc123, asset_def456
             * **Created:** 2025-10-14T00:00:00.000Z
             */
            message?: string;
          };
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Get creative
   * @description Get detailed information about a specific creative.
   */
  creative_get: {
    requestBody: {
      content: {
        'application/json': {
          /** @description Internal database ID of the creative to retrieve */
          creativeId: number;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Update creative
   * @description Update an existing creative's settings.
   */
  creative_update: {
    requestBody: {
      content: {
        'application/json': {
          /** @description Internal database ID of the creative to update */
          creativeId: number;
          /** @description New name for the creative */
          name?: string;
          /** @description New status for the creative */
          status?: string;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Delete creative
   * @description ⚠️ DANGER - Permanently delete a creative.
   */
  creative_delete: {
    requestBody: {
      content: {
        'application/json': {
          /** @description Internal database ID of the creative to delete */
          creativeId: number;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Assign creative to campaign
   * @description Assign a creative to a campaign. Automatically discovers and syncs the creative to all sales agents
   * associated with the campaign via active media buys. Returns auto-sync results including which agents
   * received the creative and their approval status.
   */
  creative_assign: {
    requestBody: {
      content: {
        'application/json': {
          /** @description Internal database ID of the creative to assign */
          creativeId: number;
          /** @description Internal database ID of the campaign to assign creative to */
          campaignId: number;
        };
      };
    };
    responses: {
      /** @description Creative assigned successfully with auto-sync results */
      200: {
        content: {
          'application/json': {
            content?: {
              /** @example text */
              type?: string;
              /**
               * @description Summary of creative assignment including auto-sync results.
               * Shows which sales agents received the creative and their approval status.
               */
              text?: string;
            }[];
          };
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Sync creative with sales agents
   * @description Sync a creative to sales agents using smart auto-detection or manual specification.
   * Features intelligent format matching and recent activity analysis (30-60 day lookback).
   * Provides detailed sync status and actionable next steps.
   */
  creative_sync_sales_agents: {
    requestBody: {
      content: {
        'application/json': {
          /** @description Internal database ID of the creative to sync */
          creativeId: number;
          /** @description Smart auto-detection settings (default behavior) */
          autoDetect?: {
            /** @description Look at tactics from past N days (default 30, max 90) */
            daysBack?: number;
            /** @description Include agents from active campaigns (default true) */
            includeActive?: boolean;
          };
          /** @description Internal database ID - sync to sales agents used by this campaign's tactics only */
          campaignId?: number;
          /** @description Request pre-approval before campaign launch (default false) */
          preApproval?: boolean;
          /** @description Explicitly specify ADCP agent IDs (overrides auto-detection) */
          adcpAgentIds?: string[];
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * List sales agents
   * @description List all registered sales agents (publishers) for the authenticated customer.
   */
  sales_agent_list: {
    requestBody: {
      content: {
        'application/json': Record<string, never>;
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Get sales agent
   * @description Get detailed information about a specific sales agent.
   */
  sales_agent_get: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the sales agent to retrieve */
          salesAgentId: string;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Register sales agent
   * @description Register a new sales agent. Creates a row in the adcp_agent table. Organization ID is auto-detected from customer if not provided.
   */
  sales_agent_register: {
    requestBody: {
      content: {
        'application/json': {
          /** @description Sales agent name */
          name: string;
          /** @description Sales agent endpoint URL */
          endpointUrl: string;
          /**
           * @description Protocol for endpoint URL calls
           * @enum {string}
           */
          protocol: 'MCP' | 'A2A';
          /**
           * @description Authentication type
           * @enum {string}
           */
          authenticationType: 'API_KEY' | 'OAUTH' | 'NO_AUTH';
          /** @description Sales agent description (optional) */
          description?: string;
          /** @description Organization ID (optional - auto-detected from customer if not provided) */
          organizationId?: string;
          /** @description Authentication configuration for the sales agent (optional) */
          authConfig?: Record<string, never>;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * List accounts for a sales agent
   * @description List all accounts registered by your organization for a specific sales agent.
   */
  sales_agent_account_list: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the sales agent */
          salesAgentId: string;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Register account for sales agent
   * @description Register your organization's account to an existing sales agent. This allows you to access the sales agent's inventory and services.
   */
  sales_agent_account_register: {
    requestBody: {
      content: {
        'application/json': {
          /** @description Sales agent ID */
          salesAgentId: string;
          /** @description Account identifier */
          accountIdentifier: string;
          /** @description Authentication configuration (credentials, tokens, etc.) - optional */
          authConfig?: Record<string, never>;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Unregister sales agent completely
   * @description Completely unregister a sales agent - deactivates ALL customer accounts and disables the agent itself. Only the owner can perform this action.
   */
  sales_agent_unregister: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the sales agent to unregister */
          salesAgentId: string;
          /** @description Must be true to confirm this destructive operation */
          confirm: boolean;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Unregister your account with a sales agent
   * @description Unregister (deactivate) your organization's account with a sales agent. This only deactivates your account but doesn't affect the sales agent or other customers' accounts.
   */
  sales_agent_account_unregister: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the sales agent to unregister your account from */
          salesAgentId: string;
          /** @description Must be true to confirm this destructive operation */
          confirm: boolean;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Update sales agent
   * @description Update a sales agent's core settings like name, description, or endpoint URL. Only the owner can perform this action.
   */
  sales_agent_update: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the sales agent to update */
          salesAgentId: string;
          /** @description New name */
          name?: string;
          /** @description New description */
          description?: string;
          /** @description New endpoint URL */
          endpointUrl?: string;
          /**
           * @description New protocol
           * @enum {string}
           */
          protocol?: 'REST' | 'MCP' | 'A2A' | 'CUSTOM';
          /**
           * @description New authentication type
           * @enum {string}
           */
          authenticationType?: 'API_KEY' | 'OAUTH' | 'NO_AUTH';
          /** @description Authentication configuration for the sales agent */
          authConfig?: Record<string, never>;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Update sales agent account authentication
   * @description Update your organization's account authentication configuration for a sales agent. This endpoint only handles authentication updates.
   */
  sales_agent_account_update: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the sales agent */
          salesAgentId: string;
          /** @description Account identifier to update */
          accountIdentifier: string;
          /** @description Updated authentication configuration (credentials, tokens, etc.) */
          authConfig: Record<string, never>;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * List tactics
   * @description List all media buying tactics for the authenticated customer.
   */
  strategy_list: {
    requestBody: {
      content: {
        'application/json': {
          /** @description Optional campaign ID to filter tactics */
          campaignId?: string;
          /** @description Include archived tactics (defaults to false) */
          includeArchived?: boolean;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Create tactic
   * @description Create a new AMP media buy tactic for executing media buys with publishers. Tactics are automatically configured as activityType=AMP and tacticType=INTELLIGENT_CAMPAIGNS. Use channel_list to see valid channel codes.
   */
  strategy_create: {
    requestBody: {
      content: {
        'application/json': {
          /** @description Name of the tactic */
          name: string;
          /** @description Campaign ID to link this tactic to (required) */
          campaignId: string;
          /** @description Optional tactical brief or prompt for this tactic */
          prompt?: string;
          /** @description Valid channel codes to target (also accepts friendly aliases like audio, web, app, ctv, video which are automatically mapped) */
          channelCodes?: (
            | 'DIGITAL-AUDIO'
            | 'DISPLAY-WEB'
            | 'DISPLAY-APP'
            | 'CTV-BVOD'
            | 'OLV'
            | 'DOOH'
            | 'SOCIAL'
          )[];
          /** @description Country codes to target (2-digit ISO codes) */
          countryCodes?: string[];
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Get tactic
   * @description Get detailed information about a specific tactic.
   */
  strategy_get: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the tactic to retrieve */
          tacticId: string;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Update tactic
   * @description Update an existing tactic's configuration.
   */
  strategy_update: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the tactic to update */
          tacticId: string;
          /** @description New name for the tactic */
          name?: string;
          /** @description New tactical brief */
          prompt?: string;
          /** @description Updated channel codes (also accepts friendly aliases like audio, web, app, ctv, video) */
          channelCodes?: (
            | 'DIGITAL-AUDIO'
            | 'DISPLAY-WEB'
            | 'DISPLAY-APP'
            | 'CTV-BVOD'
            | 'OLV'
            | 'DOOH'
            | 'SOCIAL'
          )[];
          /** @description Updated country codes */
          countryCodes?: string[];
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Delete tactic
   * @description ⚠️ DANGER - Permanently delete a tactic.
   */
  strategy_delete: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the tactic to delete */
          tacticId: string;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Link campaign to tactic
   * @description Link a campaign to a tactic for budget and execution management.
   */
  strategy_link_campaign: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the tactic */
          tacticId: string;
          /** @description ID of the campaign to link */
          campaignId: string;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Unlink campaign from tactic
   * @description Unlink a campaign from a tactic.
   */
  strategy_unlink_campaign: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the tactic */
          tacticId: string;
          /** @description ID of the campaign to unlink */
          campaignId: string;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * List media buys
   * @description List all media buys for the authenticated customer.
   */
  media_buy_list: {
    requestBody: {
      content: {
        'application/json': {
          /** @description Optional tactic ID to filter media buys */
          tacticId?: string;
          /** @description Optional campaign ID to filter media buys */
          campaignId?: string;
          /** @description Include archived media buys (defaults to false) */
          includeArchived?: boolean;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Create media buy
   * @description Create a new media buy to execute a tactic with one or more publisher products. A media buy represents the actual execution of a tactic with budget allocation and pricing.
   *
   * **Multi-Product Support**: Media buys now support multiple products from different sales agents in a single buy. Each product can have its own budget allocation and pricing. During execution, each unique sales agent will receive a separate ADCP submission.
   *
   * **Budget Validation**: The sum of product budget allocations must not exceed the total media buy budget. The system will validate this at creation time and show warnings if budget is under-allocated.
   */
  media_buy_create: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the tactic to execute */
          tacticId: string;
          /** @description Name of the media buy */
          name: string;
          /** @description Optional description of the media buy */
          description?: string;
          /** @description Array of products to include in this media buy. At least one product is required. Each product will be validated with its sales agent. */
          products: {
            /** @description Media product ID from publisher (will be validated with sales agent) */
            mediaProductId: string;
            /** @description Sales agent ID for this product */
            salesAgentId: string;
            /** @description Budget allocated to this specific product (optional, must not exceed total budget when summed across all products) */
            budgetAmount?: number;
            /** @description Currency for this product's budget (defaults to media buy currency) */
            budgetCurrency?: string;
            /** @description Base CPM price for this product */
            pricingCpm?: number;
            /** @description Additional signal cost for this product */
            pricingSignalCost?: number;
            /** @description Optional display order for organizing products */
            displayOrder?: number;
          }[];
          budget: {
            /** @description Total budget amount for this media buy */
            amount: number;
            /** @description Currency code (defaults to USD) */
            currency?: string;
            /** @description Optional daily spending cap */
            dailyCap?: number;
            /**
             * @description Budget pacing tactic (defaults to even)
             * @enum {string}
             */
            pacing?: 'asap' | 'even' | 'front_loaded';
          };
          /** @description Optional array of creative IDs (database IDs) to assign to this media buy. Creatives must be assigned to the campaign associated with this media buy's tactic. */
          creativeIds?: string[];
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Get media buy
   * @description Get detailed information about a specific media buy.
   */
  media_buy_get: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the media buy to retrieve */
          mediaBuyId: string;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Update media buy
   * @description Update an existing media buy's configuration.
   */
  media_buy_update: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the media buy to update */
          mediaBuyId: string;
          /** @description New name */
          name?: string;
          budget?: {
            amount?: number;
            dailyCap?: number;
            /** @enum {string} */
            pacing?: 'asap' | 'even' | 'front_loaded';
          };
          /** @description New CPM price */
          cpm?: number;
          /** @description Array of creative IDs (database IDs) to assign to this media buy. Replaces existing assignments. Creatives must be assigned to the campaign associated with this media buy's tactic. */
          creativeIds?: string[];
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Delete media buy
   * @description ⚠️ DANGER - Permanently delete a media buy.
   */
  media_buy_delete: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the media buy to delete */
          mediaBuyId: string;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Execute media buy
   * @description Execute a media buy by deploying it to the publisher platform.
   */
  media_buy_execute: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the media buy to execute */
          mediaBuyId: string;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * List notifications
   * @description List notifications for the authenticated user.
   */
  notifications_list: {
    requestBody: {
      content: {
        'application/json': {
          /** @description Filter to only unread notifications */
          unreadOnly?: boolean;
          /** @description Maximum number of notifications to return */
          limit?: number;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Mark notification as read
   * @description Mark a specific notification as read.
   */
  notifications_mark_read: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the notification to mark as read */
          notificationId: string;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Mark notification as acknowledged
   * @description Mark a specific notification as acknowledged.
   */
  notifications_mark_acknowledged: {
    requestBody: {
      content: {
        'application/json': {
          /** @description ID of the notification to mark as acknowledged */
          notificationId: string;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Mark all notifications as read
   * @description Mark all notifications as read for the authenticated user.
   */
  notifications_mark_all_read: {
    requestBody: {
      content: {
        'application/json': Record<string, never>;
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * List media products
   * @description List available media products from publishers.
   */
  media_product_list: {
    requestBody: {
      content: {
        'application/json': {
          /** @description Optional sales agent ID to filter products */
          salesAgentId?: string;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Discover media products
   * @description Discover new media products from connected publishers.
   */
  media_product_discover: {
    requestBody: {
      content: {
        'application/json': {
          /** @description Sales agent ID to discover products from */
          salesAgentId?: string;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  /**
   * Sync media products
   * @description Synchronize media product inventory with publisher systems.
   */
  media_product_sync: {
    requestBody: {
      content: {
        'application/json': {
          /** @description Sales agent ID to sync products from */
          salesAgentId: string;
        };
      };
    };
    responses: {
      200: components['responses']['ToolResponse'];
      401: components['responses']['Unauthorized'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
}
